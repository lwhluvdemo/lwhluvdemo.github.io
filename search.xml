<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>新手教程</title>
      <link href="/2019/10/19/ckmte2mzm0005boudyafh0lz9/"/>
      <url>/2019/10/19/ckmte2mzm0005boudyafh0lz9/</url>
      
        <content type="html"><![CDATA[<p>就目前而言，python很适合编程零基础同学上手，也非常适合做学术研究和分析。举个简单例子，和matlab，c++等相比，python更加简便轻巧易上手，而且matlab能做的，python都能做，且比其应用更广泛，python免费开源，社区更加活跃等等有点，从来不需要为寻找破解而头痛。另一个是所有的研究都需要生成报告或PPT，文字和优雅的图片哪个更好？看下面例子</p><p><a href="https://www.kaggle.com/kabure/extensive-eda-and-modeling-xgb-hyperopt" target="_blank" rel="noopener">一个优秀的EDA(数据可视化分析)</a>。（电脑打开）</p><p>还有今年的就业形势，即使你不就业选择考研，那么读研真正搞学术研究还是要学多门编程语言，但那时你的进度一定跟不上大众。</p><p><a href="https://mp.weixin.qq.com/s/tuh5iMLgIbcbs5RkYOrtGA" target="_blank" rel="noopener">车企不招车辆工程</a>.</p><blockquote><p>如果人工智能是概念里的一栋房子，那么python就是盖房子的材料，当然别的语言比如c或者java等等也能盖房子，但就像稻草、木材和砖块一样，房子需要在美观、坚固各方面取得平衡。从速度上来说，python并不具有明显优势，但它的优势在于简单、灵活，在人工智能领域用起来就格外方便，也格外适合进行一系列的学术研究。</p></blockquote><a id="more"></a><h2 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h2><p>培训先决条件：</p><ol><li>抛弃百度，学会谷歌</li><li>直接安装anaconda.</li></ol><h3 id="视野拓展："><a href="#视野拓展：" class="headerlink" title="视野拓展："></a>视野拓展：</h3><p><strong><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a></strong>：这是广大开发者们的圣地与乐园，GitHub 上除了有各大科技公司的顶级开源项目，也活跃着众多具有业界影响力的开源先锋们，而在去年 11 月，GitHub 的仓库数量已经突破了一个亿。但事实上，除了正儿八经的开源项目，GitHub 上还有许多令人哭笑不得的开源项目，看完以后你会发现，原来 GitHub 还可以这样玩。</p><p><strong><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stackoverflow</a></strong>：<a href="https://www.techug.com/post/why-programmer-must-use-google-and-stack-overflow.html" target="_blank" rel="noopener">为什么程序员一定要会用Google和Stack Overflow？</a>.</p><p><a href="https://www.zhihu.com/question/27574436" target="_blank" rel="noopener">编程新手如何提高编程能力？</a>.</p><p><a href="https://mp.weixin.qq.com/s/m22RDvVV5wZLcZsZbgP5FA" target="_blank" rel="noopener">为什么程序员在学习编程的时候什么都记不住？</a>.</p><h3 id="基础教程"><a href="#基础教程" class="headerlink" title="基础教程"></a>基础教程</h3><p><a href="https://segmentfault.com/a/1190000017949680#articleHeader0" target="_blank" rel="noopener">vscode教程（基础篇）</a>.</p><p><a href="https://www.jiqizhixin.com/articles/2018-05-30-5" target="_blank" rel="noopener">始于Jupyter Notebooks：一份全面的初学者实用指南</a>,</p><p>这篇文章最后的部分：</p><blockquote><p>这个 GitHub 库包含了一些有趣迷人的 Jupyter Notebooks：<a href="https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks" target="_blank" rel="noopener">https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks</a>，这个链接很详细</p></blockquote><p><a href="https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/Lecture-4-Matplotlib.ipynb" target="_blank" rel="noopener">matplotlib - 2D and 3D plotting in Python</a>.——&gt;一个很酷的可视化教程</p><p><a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">makedown教程</a>.</p><p>正则表达式</p><blockquote><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017639890281664" target="_blank" rel="noopener">廖雪峰正则表达式教程</a>。</p><p><a href="http://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener">正则化教程(字典式)</a>，———&gt;测试地址(<a href="https://tool.lu/regex/" target="_blank" rel="noopener">https://tool.lu/regex/</a>)</p></blockquote><p><a href="https://juejin.im/post/5c05e1bc518825689f1b4948" target="_blank" rel="noopener">Google Colab 免费 GPU 使用教程</a>，（放在培训比较靠后的阶段，）</p><h3 id="深入："><a href="#深入：" class="headerlink" title="深入："></a>深入：</h3><p><a href="https://github.com/microsoft" target="_blank" rel="noopener">microsoft</a>/<a href="https://github.com/microsoft/computerscience" target="_blank" rel="noopener">computerscience</a>：</p><p>微软：针对教师，学生和开发者的免费技术资源，可用于计算机科学课程，研讨会和黑客马拉松。</p><p><a href="https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version" target="_blank" rel="noopener">利用Python进行数据分析·第2版</a>，</p><p><a href="https://www.tutorialspoint.com/index.htm" target="_blank" rel="noopener">最大的在线教程库，全部免费</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 协会新手教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲聊</title>
      <link href="/2019/10/02/ckmte2n1a000xboudnog44jhj/"/>
      <url>/2019/10/02/ckmte2n1a000xboudnog44jhj/</url>
      
        <content type="html"><![CDATA[<p>From：全部来自CVer群里“Leo林”大佬的一些闲聊</p><p>这里好像不少毕业找工作的，说一些建议吧:</p><ol><li>充分评估自己的能力，不要总想着 BAT 这样的大公司。<br>大公司人才济济，说实话，除非天才类型，否则各个位置上都占好了坑，要上位不容易的。<br>大多数毕业生都是大公司用来筛选的基数，给你个 2年高工资无所谓，但一般半年后就开始见分晓，该转岗去填劳力的就强制转，不转的话看你是想去哪？拿着高薪不做事？<br>一般降薪比较难操作，直接开掉比较容易。开老员工容易伤感情，赔偿还多，开工作一两年就简单很多。<br>总之呢，大公司高薪找毕业生其实是一种大撒网策略，不要真以为就是自己值这个钱。</li></ol><a id="more"></a><ol><li>目前人工智能在风头上，但今年产业发展已经开始回归理性，大多数公司在讨论的是怎么落地。这个时候大公司给高工资招的算法，一到两年内冷下来之后就很危险。大公司也不是做慈善的，不会养一批人做纯研究的。如果在公司做的算法和产品脱离了，自己就真要当心想一想了。不讲业绩的部门，也就不受重视，自己前途如何，要心里有数。做研究类的算法，真正能转化为产品的应该不会高于30%。<br>等风口冷下来了，也是大公司就高薪酬年轻人动刀的 时候了</li></ol><p>大公司每年招那么多人，其实就和鲸鱼差不多，先把鱼虾海水啥的都吞进来，然后再过滤掉，那一两年的工资差负担的起。否则为啥每年招那么多毕业生公司还在不停的招，真的是业务发展的需求？看看公司每年的增长率是多少就知道了。拿高薪人人都想，但是真的要搞清楚自己是不是准备被过滤掉的那批。2年后再出来，风口已过，到处都是被大公司筛出来的，还要和应届生再竞争了</p><p>真的是不是白菜价只有公司内部知道，如果凭着风口和老员工薪酬倒挂，那就更危险。要调老员工是大规模的调，公司受不了的，那如果短时间内没有做出大的贡献或者证明不了自己，看公司是情愿把所有的老员工薪酬调的和你一样，还是直接把你开了简单？</p><p>2年跳一次，到底是能力问题还是态度问题呀？到底是被开的还是自己辞职的呀？HR 冒不起这个风险呀<br>跳了以后，除非是行业内大牛，在新公司又要花个几年去铺垫才能上位，上不了位就只能一直待在某一个层级，10年工作还没有进展，以后基本就这样层次了</p><p>公司招人进来，HR 都是会评估的。<br>这个人未来是否可以长期培养，是否资源和态度方面可以向他倾斜，这些都是你背后一只看不见的手。<br>如果定位是招进来干2年活，做做事情，那也不需要花太多精力去照顾，反正迟早要走的</p><p>不是劝退，只是想说，不要只看着大公司的高薪酬。<br>要评估一下自己的能力，是否技术和能力真的好，能在大公司和全国的人才拼一拼。<br>如果自己是 20% 以下的，有比较靠谱的中型公司，有明确的技术前景，也可以考虑。潜心做几年，中小公司反而比较愿意花精力培养新人，当然前提是真的研发为核心的技术公司，而不是贸易公司。</p><p>每个人有每个人的造化，中小型公司也有风险。总得来说运气比实力占的比重大。工作以后也不单看技术，还要看沟通能力。能否把自己做的事情讲出来。只会技术讲不出来的，安安静静做个技术型专家也未尝不可。会技术又能讲得出来的，可以往技术领头人方向走。嘴皮子比较厉害，无心做技术的，做两年最好就考虑转方向</p><p>进了大公司的，头一年要保持些敏感度，和周边的人对比一下，看看自己是否真的有竞争力，一年内主动走的，下家企业基本是能按毕业生的角度来看的。2年后再走的，一般就按社招来判断了，会比较关心你跳槽的原因是什么了</p><p>转哪里就看自己的优势所在了，技术精英总归是少数，做个非精英部队的头部也不错的。如果工作了两年还没搞清楚自己的优势所在，我觉得最好就找个咨询公司帮忙做一下自己的职业规划做个参考。<br>现在好像也蛮多这样的服务的，花点钱值得</p><p>另外，有一个错觉是大公司学技术会比较好，其实大公司大多流程化，长时间可能就只能做一小块事情的。要转岗跳项目组多少有些忌讳。<br>中小公司反而因为缺人，很快就要负责很多事情，累肯定累，但学得东西也多。长远来说，这方面倒是比薪酬其实带来的价值会更大一些</p>]]></content>
      
      
      
        <tags>
            
            <tag> 工作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双指针</title>
      <link href="/2019/09/19/ckmte2n16000uboudqlb0ba4o/"/>
      <url>/2019/09/19/ckmte2n16000uboudqlb0ba4o/</url>
      
        <content type="html"><![CDATA[<h2 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">删除排序数组中的重复项</a></h2><p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。</p><p>不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。</p><p>示例 1:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给定数组 nums = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>], </span><br><span class="line"></span><br><span class="line">函数应该返回新的长度 <span class="number">2</span>, 并且原数组 nums 的前两个元素被修改为 <span class="number">1</span>, <span class="number">2</span>。 </span><br><span class="line"></span><br><span class="line">你不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><a id="more"></a><p>题目要求两件事：</p><ul><li>统计数组中不同数字数量 $k$ ；</li><li>修改数组前 $k$ 个元素为这些不同数字。</li></ul><p>算法流程：</p><ul><li>第一个指针 $i$ ： 由于数组已经完成排序，因此遍历数组，每遇到 $nums[i] \not= nums[i - 1]$，就说明遇到了新的不同数字，记录之；</li><li>第二个指针 $k$ ： 每遇到新的不同数字时，执行$k+=1$ ，$k$ 指针有两个作用：<ul><li>记录数组中不同数字的数量；</li><li>作为修改数组元素的索引<code>index</code>。</li></ul></li><li>最终，返回 $k$ 即可。</li></ul><h4 id="解答："><a href="#解答：" class="headerlink" title="解答："></a><strong>解答：</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">removeDuplicates</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        k = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,len(nums)):</span><br><span class="line">            <span class="keyword">if</span> nums[i] != nums[i<span class="number">-1</span>]:</span><br><span class="line">                nums[k] = nums[i]</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> k</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，假设数组的长度是 $n$，那么 $i$ 和 $j$ 分别最多遍历 $n$ 步。</li><li>空间复杂度：$O(1)$。</li></ul><h2 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88. 合并两个有序数组"></a>88. <a href="https://leetcode-cn.com/problems/merge-sorted-array/" target="_blank" rel="noopener">合并两个有序数组</a></h2><p>给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。</p><p><strong>说明:</strong></p><ul><li>初始化 nums1 和 nums2 的元素数量分别为 m 和 n。</li><li>你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素</li></ul><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">nums1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>], m = <span class="number">3</span></span><br><span class="line">nums2 = [<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>],       n = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure><h4 id="解法一：双指针-从前往后"><a href="#解法一：双指针-从前往后" class="headerlink" title="解法一：双指针 / 从前往后"></a><strong>解法一：</strong>双指针 / 从前往后</h4><p>一般而言，对于有序数组可以通过 双指针法 达到$O(n + m)$的时间复杂度。</p><p>最直接的算法实现是将指针<code>p1</code> 置为 <code>nums1</code>的开头， <code>p2</code>为 <code>nums2</code>的开头，在每一步将最小值放入输出数组中。</p><p>由于 <code>nums1</code> 是用于输出的数组，需要将<code>nums1</code>中的前<code>m</code>个元素放在其他地方，也就需要 $O(m)$ 的空间复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># Make a copy of nums1.</span></span><br><span class="line">        nums1_copy = nums1[:m] </span><br><span class="line">        nums1[:] = []</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Two get pointers for nums1_copy and nums2.</span></span><br><span class="line">        p1 = <span class="number">0</span> </span><br><span class="line">        p2 = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Compare elements from nums1_copy and nums2</span></span><br><span class="line">        <span class="comment"># and add the smallest one into nums1.</span></span><br><span class="line">        <span class="keyword">while</span> p1 &lt; m <span class="keyword">and</span> p2 &lt; n: </span><br><span class="line">            <span class="keyword">if</span> nums1_copy[p1] &lt; nums2[p2]: </span><br><span class="line">                nums1.append(nums1_copy[p1])</span><br><span class="line">                p1 += <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1.append(nums2[p2])</span><br><span class="line">                p2 += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># if there are still elements to add</span></span><br><span class="line">        <span class="keyword">if</span> p1 &lt; m: </span><br><span class="line">            nums1[p1 + p2:] = nums1_copy[p1:]</span><br><span class="line">        <span class="keyword">if</span> p2 &lt; n:</span><br><span class="line">            nums1[p1 + p2:] = nums2[p2:]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(n + m)$。</li><li>空间复杂度 : $O(m)$。</li></ul><h4 id="解法二-双指针-从后往前"><a href="#解法二-双指针-从后往前" class="headerlink" title="解法二 : 双指针 / 从后往前"></a>解法二 : 双指针 / 从后往前</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, nums1, m, nums2, n)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type nums1: List[int]</span></span><br><span class="line"><span class="string">        :type m: int</span></span><br><span class="line"><span class="string">        :type nums2: List[int]</span></span><br><span class="line"><span class="string">        :type n: int</span></span><br><span class="line"><span class="string">        :rtype: void Do not return anything, modify nums1 in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="comment"># two get pointers for nums1 and nums2</span></span><br><span class="line">        p1 = m - <span class="number">1</span></span><br><span class="line">        p2 = n - <span class="number">1</span></span><br><span class="line">        <span class="comment"># set pointer for nums1</span></span><br><span class="line">        p = m + n - <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># while there are still elements to compare</span></span><br><span class="line">        <span class="keyword">while</span> p1 &gt;= <span class="number">0</span> <span class="keyword">and</span> p2 &gt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">if</span> nums1[p1] &lt; nums2[p2]:</span><br><span class="line">                nums1[p] = nums2[p2]</span><br><span class="line">                p2 -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                nums1[p] =  nums1[p1]</span><br><span class="line">                p1 -= <span class="number">1</span></span><br><span class="line">            p -= <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># add missing elements from nums2</span></span><br><span class="line">        nums1[:p2 + <span class="number">1</span>] = nums2[:p2 + <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(n + m)$。</li><li>空间复杂度 : $O(1)$。</li></ul><h2 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a>125. <a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">验证回文串</a></h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p><strong>说明：</strong>本题中，我们将空字符串定义为有效的回文串。</p><p><strong>示例 :</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="string">"A man, a plan, a canal: Panama"</span></span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><h4 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h4><p><strong>思路：</strong></p><ul><li>设置一个头指针和一个尾指针</li><li>头指针从头开始找，找到第一个数字或字符</li><li>尾指针从尾开始找，找到最后一个数字或字符</li><li>比较两者是否相同，不同就return False</li><li>相同则两指针往中间靠</li><li>当 i &gt; j 的时候，return True</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        i, j = <span class="number">0</span>, len(s) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> i &lt; j:</span><br><span class="line">            <span class="comment"># isalnum() 方法检测字符串是否由字母和数字组成</span></span><br><span class="line">            <span class="keyword">while</span> i &lt; len(s) <span class="keyword">and</span> <span class="keyword">not</span> s[i].isalnum():</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">-1</span> <span class="keyword">and</span> <span class="keyword">not</span> s[j].isalnum():</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; j:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">if</span> s[i].upper() != s[j].upper():</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i += <span class="number">1</span></span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 <strong>O(N)</strong>, 遍历一遍数组。</li><li>空间复杂读 <strong>O(1)</strong>，只使用了常量的空间。</li></ul><p>同思想另一种写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">       l = <span class="number">0</span></span><br><span class="line">       r = len(s)<span class="number">-1</span></span><br><span class="line">       <span class="keyword">while</span> l &lt; r:</span><br><span class="line">           <span class="keyword">if</span> s[l].isalnum() <span class="keyword">and</span> s[r].isalnum():</span><br><span class="line">               <span class="keyword">if</span> s[l].upper() == s[r].upper():</span><br><span class="line">                   l += <span class="number">1</span></span><br><span class="line">                   r -= <span class="number">1</span></span><br><span class="line">               <span class="keyword">else</span>:</span><br><span class="line">                   <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">           <span class="keyword">else</span>:</span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> s[l].isalnum():</span><br><span class="line">                   l += <span class="number">1</span></span><br><span class="line">               <span class="keyword">if</span> <span class="keyword">not</span> s[r].isalnum():</span><br><span class="line">                   r -= <span class="number">1</span></span><br><span class="line">       <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>其他解法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, s: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">""</span>.join(filter(str.isalnum, s)).lower()[::<span class="number">-1</span>]) == (<span class="string">""</span>.join(filter(str.isalnum, s)).lower())</span><br><span class="line"><span class="comment">########分开写</span></span><br><span class="line">s = <span class="string">""</span>.join(filter(str.isalnum, s)).lower()</span><br><span class="line"><span class="keyword">return</span> s[::<span class="number">-1</span>] == s</span><br></pre></td></tr></table></figure><h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a>141. <a href="https://leetcode-cn.com/problems/linked-list-cycle/" target="_blank" rel="noopener">环形链表</a></h2><p>给定一个链表，判断链表中是否有环。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。</p><p><strong>示例 1：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-4</span>], pos = <span class="number">1</span></span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><ul><li>设两指针fast slow指向链表头部head，迭代：<ul><li>fast每轮走两步，slow每轮走一步，这样两指针每轮后距离+1;</li><li>若链表中存在环，fast和slow一定会在将来相遇（距离连续+1，没有跳跃）；</li></ul></li><li>若fast走到了链表尾部，则说明链表无环。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        fast, slow = head, head</span><br><span class="line">        <span class="keyword">while</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">            fast = fast.next.next</span><br><span class="line">            slow = slow.next</span><br><span class="line">            <span class="keyword">if</span> fast == slow: <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type head: ListNode</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        save = set()</span><br><span class="line">        cur = head </span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur <span class="keyword">in</span> save:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                save.add(cur)</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2019/09/12/ckmte2n0r000qboudnnpe193y/"/>
      <url>/2019/09/12/ckmte2n0r000qboudnnpe193y/</url>
      
        <content type="html"><![CDATA[<h4 id="比赛群学习笔记"><a href="#比赛群学习笔记" class="headerlink" title="比赛群学习笔记"></a>比赛群学习笔记</h4><p>如果某个特征很强很强，那么原样拷贝一下，构造一个新的特征。会怎样？</p><p>分裂次数，首先，每个特征复杂度不同。。自身能分裂的次数就是不定的。</p><p>道理上，这样普遍情况下肯定没用。<br>但是两个特征肯定会有原特征一半左右的特征重要性，那么这个表面看，还是强特呢</p><p>我看的<a href="https://github.com/WillKoehrsen/feature-selector" target="_blank" rel="noopener">这个链接</a>，按照林佬的讲法，这个feature-selector有些思路也是有问题的，我觉得我也要再想想想，模型只有学到，在测试集中依旧有用的信息，才有价值，构建好一致的线下验证集，是成功的一半，其实影响得分最大的因素是验证数据</p><p>线下5折的时候。每折的得分的方差大，还是同一个折，换不同的5个种子的方差大？其实很明显是前者。</p><p>绝大部分误差是数据真实标签带来的。。一般说的线下线上一致，都是指增减一致。而不是分数接近。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>pandas技巧</title>
      <link href="/2019/09/05/ckmte2mzf0003boudjbj9382x/"/>
      <url>/2019/09/05/ckmte2mzf0003boudjbj9382x/</url>
      
        <content type="html"><![CDATA[<h4 id="用一列的非空值填充另一列对应行的空值"><a href="#用一列的非空值填充另一列对应行的空值" class="headerlink" title="用一列的非空值填充另一列对应行的空值"></a>用一列的非空值填充另一列对应行的空值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用数据框df的name列中的非空值，去填充df的features_1列中对应的NaN。</span></span><br><span class="line">df.loc[df[<span class="string">'features_1'</span>].isnull(),<span class="string">'features_1'</span>]=df[df[<span class="string">'features_1'</span>].isnull()][‘name’]</span><br></pre></td></tr></table></figure><a id="more"></a><h4 id="填充缺失值"><a href="#填充缺失值" class="headerlink" title="填充缺失值"></a>填充缺失值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#填充缺失值</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string_feature+other_feature:</span><br><span class="line">    mode_num = data[i].mode()[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> (mode_num != <span class="number">-1</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        data.loc[data[i] == <span class="number">-1</span>, i] = mode_num</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="number">-1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> numeric_feature:</span><br><span class="line">    mean_num = data[i].mean()</span><br><span class="line">    <span class="keyword">if</span> (mean_num != <span class="number">-1</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        data.loc[data[i] == <span class="number">-1</span>, i] = mean_num</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>判断两个list是否是父子集关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">c = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">set(b) &gt; set(a)</span><br><span class="line">set(b) &gt; set(c)</span><br></pre></td></tr></table></figure><p>求列表差值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(set(a).difference(set(b)))</span><br></pre></td></tr></table></figure><p>按列时间值筛选 Pandas DataFrame</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> io</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t=<span class="string">"""2015-01-01 04:00:00</span></span><br><span class="line"><span class="string">2015-01-01 05:00:00</span></span><br><span class="line"><span class="string">2015-01-01 06:00:00</span></span><br><span class="line"><span class="string">2015-01-01 07:00:00</span></span><br><span class="line"><span class="string">2015-01-02 04:00:00</span></span><br><span class="line"><span class="string">2015-01-02 05:00:00</span></span><br><span class="line"><span class="string">2015-01-02 06:00:00</span></span><br><span class="line"><span class="string">2015-01-02 07:00:00"""</span></span><br><span class="line">s = pd.read_csv(io.StringIO(t), parse_dates=[<span class="number">0</span>], header=<span class="literal">None</span>, names=[<span class="string">'date'</span>])</span><br><span class="line">s[(s[<span class="string">'date'</span>].dt.hour &lt;= <span class="number">6</span>)&amp;(s[<span class="string">'date'</span>].dt.hour &gt;= <span class="number">2</span>)]</span><br></pre></td></tr></table></figure><p>计算真值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.count_nonzero(df[col].value_counts().reset_index()[col].values&gt;=<span class="number">600</span>)</span><br></pre></td></tr></table></figure><p>每列的最大值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train_df.ix[train_df.idxmax()].iloc[:,<span class="number">60</span>:<span class="number">120</span>].max()</span><br></pre></td></tr></table></figure><p> 同类特征正则匹配：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同类特征正则匹配测试</span></span><br><span class="line">df = pd.DataFrame(np.array(([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">7</span>,<span class="number">7</span>])),</span><br><span class="line">                  index=[<span class="string">'mouse'</span>, <span class="string">'rabbit'</span>],</span><br><span class="line">                  columns=[<span class="string">'WebInfo_1'</span>, <span class="string">'WebInfo_2'</span>, <span class="string">'WebInfo_3'</span>,<span class="string">'ProductInfo_1'</span>,</span><br><span class="line">                  <span class="string">'ProductInfo_2'</span>,<span class="string">'ProductInfo_3'</span>,<span class="string">'ProductInfo_4'</span>,<span class="string">'UserInfo_1'</span>,</span><br><span class="line">                  <span class="string">'UserInfo_2'</span>,<span class="string">'UserInfo_3'</span>])</span><br><span class="line">df_WebInfo = df.filter(regex=<span class="string">"WebInfo_\d&#123;1,3&#125;"</span>)</span><br><span class="line">df_ProductInfo = df.filter(regex=<span class="string">"ProductInfo_\d&#123;1,3&#125;"</span>)</span><br><span class="line">df_UserInfo = df.filter(regex=<span class="string">"UserInfo_\d&#123;1,3&#125;"</span>)</span><br></pre></td></tr></table></figure><p>将一列的值填充到另一列同行的缺失值中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train.loc[train[<span class="string">'member_id'</span>].isnull(),<span class="string">'member_id'</span>] = train[train[<span class="string">'member_id'</span>]</span><br><span class="line">                                                          .isnull()][<span class="string">'customer_id'</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>keras_bert</title>
      <link href="/2019/08/29/ckmte2mz70001boud43r3rhzu/"/>
      <url>/2019/08/29/ckmte2mz70001boud43r3rhzu/</url>
      
        <content type="html"><![CDATA[<h3 id="keras-bert"><a href="#keras-bert" class="headerlink" title="keras_bert"></a>keras_bert</h3><p><a href="https://colab.research.google.com/github/CyberZHG/keras-bert/blob/master/demo/tune/keras_bert_classification_tpu.ipynb" target="_blank" rel="noopener">分类示例</a>中在IMDB数据集上对模型进行了微调以适应新的分类任务。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 会下载Bert模型</span></span><br><span class="line">!pip install -q keras-bert keras-rectified-adam</span><br><span class="line">!wget -q https://storage.googleapis.com/bert_models/<span class="number">2018</span>_10_18/uncased_L<span class="number">-12</span>_H<span class="number">-768</span>_A<span class="number">-12.</span>zip</span><br><span class="line"><span class="comment"># !wget -q https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip    # 中文</span></span><br><span class="line">!unzip -o uncased_L<span class="number">-12</span>_H<span class="number">-768</span>_A<span class="number">-12.</span>zip</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载路径</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">pretrained_path = <span class="string">'chinese_L-12_H-768_A-12'</span></span><br><span class="line">config_path = os.path.join(pretrained_path, <span class="string">'bert_config.json'</span>)</span><br><span class="line">checkpoint_path = os.path.join(pretrained_path, <span class="string">'bert_model.ckpt'</span>)</span><br><span class="line">vocab_path = os.path.join(pretrained_path, <span class="string">'vocab.txt'</span>)</span><br></pre></td></tr></table></figure><h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> keras_bert.datasets <span class="keyword">import</span> get_pretrained, PretrainedList</span><br><span class="line">model_path = get_pretrained(PretrainedList.chinese_base)</span><br><span class="line">paths = get_checkpoint_paths(model_path)</span><br><span class="line">model = load_trained_model_from_checkpoint(paths.config, paths.checkpoint, seq_len=<span class="number">10</span>)</span><br><span class="line">model.summary(line_length=<span class="number">120</span>)</span><br><span class="line">token_dict = load_vocabulary(paths.vocab)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tokenizer = Tokenizer(token_dict)</span><br><span class="line">text = <span class="string">'语言模型'</span></span><br><span class="line">tokens = tokenizer.tokenize(text)</span><br><span class="line">print(<span class="string">'Tokens:'</span>, tokens)</span><br><span class="line">indices, segments = tokenizer.encode(first=text, max_len=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">predicts = model.predict([np.array([indices]), np.array([segments])])[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i, token <span class="keyword">in</span> enumerate(tokens):</span><br><span class="line">    print(token, predicts[i].tolist()[:<span class="number">5</span>])</span><br></pre></td></tr></table></figure><h3 id="tensorboard-可视化训练过程"><a href="#tensorboard-可视化训练过程" class="headerlink" title="tensorboard 可视化训练过程"></a>tensorboard 可视化训练过程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> tensorflow.python <span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> kashgari.tasks.classification <span class="keyword">import</span> BiGRU_Model</span><br><span class="line"><span class="keyword">from</span> kashgari.callbacks <span class="keyword">import</span> EvalCallBack</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">logging.basicConfig(level=<span class="string">'DEBUG'</span>)</span><br><span class="line"></span><br><span class="line">model = BiGRU_Model()</span><br><span class="line"></span><br><span class="line">tf_board_callback = keras.callbacks.TensorBoard(log_dir=<span class="string">'./logs'</span>, update_freq=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是 Kashgari 内置回调函数，会在训练过程计算精确度，召回率和 F1</span></span><br><span class="line">eval_callback = EvalCallBack(kash_model=model,</span><br><span class="line">                             valid_x=valid_x,</span><br><span class="line">                             valid_y=valid_y,</span><br><span class="line">                             step=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># model = CNNModel()</span></span><br><span class="line">model.fit(train_x,</span><br><span class="line">          train_y,</span><br><span class="line">          val_x,</span><br><span class="line">          val_y,</span><br><span class="line">          batch_size=<span class="number">100</span>,</span><br><span class="line">          callbacks=[eval_callback, tf_board_callback])</span><br></pre></td></tr></table></figure><p>在项目目录运行下面代码即可启动 tensorboard 查看可视化效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ tensorboard --log-dir logs</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> keras </tag>
            
            <tag> bert </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2019/08/23/ckmte2mzp0007boudrw7jlref/"/>
      <url>/2019/08/23/ckmte2mzp0007boudrw7jlref/</url>
      
        <content type="html"><![CDATA[<h4 id="大O"><a href="#大O" class="headerlink" title="大O"></a>大O</h4><p>大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 </p><p>比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)<br>快得多。 </p><h4 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h4><p>“将输入映射到数字”。 </p><ul><li>模拟映射关系；</li><li>防止重复；</li><li>缓存/记住数据，以免服务器再通过处理来生成它们。 </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyspark</title>
      <link href="/2019/08/22/ckmte2mzg0004boudh7yytw7t/"/>
      <url>/2019/08/22/ckmte2mzg0004boudh7yytw7t/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pyspark <span class="keyword">import</span> SparkConf, SparkContext</span><br><span class="line"><span class="keyword">from</span> pyspark.sql <span class="keyword">import</span> SparkSession,SQLContext,DataFrame,Row</span><br><span class="line">spark= SparkSession.builder.master(<span class="string">'local'</span>).appName(<span class="string">'test'</span>).getOrCreate()</span><br><span class="line">sc = spark.sparkContext</span><br><span class="line"></span><br><span class="line">lines = sc.textFile(<span class="string">"data.txt"</span>)</span><br></pre></td></tr></table></figure><p>相关操作：<a href="https://www.jianshu.com/p/4cd22eda363f" target="_blank" rel="noopener">PySpark之RDD入门</a>.</p><p>测试：</p><p><script type="math/tex">\text { If } f\left(\mathbf{u}, \mathbf{x}^{*}\right) \leq 0 \forall \mathbf{u} \in \mathcal{U}_{\epsilon}, \quad \text { then } \mathbb{P}^{*}\left(f\left(\tilde{\mathbf{u}}, \mathbf{x}^{*}\right) \leq 0\right) \geq 1-\epsilon \tag{2}</script>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> pyspark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法竞赛一些问题总结</title>
      <link href="/2019/08/20/ckmte2n18000wboud7ug1r3np/"/>
      <url>/2019/08/20/ckmte2n18000wboud7ug1r3np/</url>
      
        <content type="html"><![CDATA[<h3 id="L1和L2范数都是用来避免过拟合问题，那么请问在使用的时候二者有何区别呢？"><a href="#L1和L2范数都是用来避免过拟合问题，那么请问在使用的时候二者有何区别呢？" class="headerlink" title="L1和L2范数都是用来避免过拟合问题，那么请问在使用的时候二者有何区别呢？"></a>L1和L2范数都是用来避免过拟合问题，那么请问在使用的时候二者有何区别呢？</h3><ul><li>L1范数是对系数<code>绝对值之和的约束</code>。梯度会比较陡，通过求导可以知道，当某些特征作用不大的时候，会使得对应的系数为0，主要用于稀疏特征的约束，比如one-hot编码。</li><li>L2范数是对系数<code>平方和的约束</code>，从而简化模型。梯度会比较缓，通过求导可以知道，系数很难达到0，因此L2范数不仅能够简化模型，也不会像L1范数一样，迫使模型忽略某些特征，一般来说，如果特征不是很稀疏，可以使用L2。</li><li>L1正则假设参数符合拉普拉斯分布，L2正则假设参数符合正态分布。从梯度来看，L2正则对数值大的参数惩罚大，对数值小的参数惩罚小，而L1对参数的惩罚恒定。于是L1容易把不太重要的特征的参数“惩罚”到0，从而产生稀疏的解。</li></ul><a id="more"></a><h3 id="比赛做特征工程是一个一个特征加进去试试比较好，还是先做完一堆特征然后再挑比较好？"><a href="#比赛做特征工程是一个一个特征加进去试试比较好，还是先做完一堆特征然后再挑比较好？" class="headerlink" title="比赛做特征工程是一个一个特征加进去试试比较好，还是先做完一堆特征然后再挑比较好？"></a>比赛做特征工程是一个一个特征加进去试试比较好，还是先做完一堆特征然后再挑比较好？</h3><p>​        首先要大致清楚模型能学到什么样的特征。</p><p>​        然后当你做一个特征的时候，你要想清楚为什么这样尝试？为什么你认为这个特征有用，比如，以前的类似比赛用过类似的特征；通过对业务的理解进行推理出来的；通过数据观察(EDA)，发现该特征下，label的表现差异比较大（如果特征是随机数的时候，label理论上差异是最小的），一个具有良好依据的特征解释，是特征有效的根本。</p><p>​        最直接有效的特征验证的方法就是代入模型验证，所以一个合理的验证策略变得极为重要。这里一定要留意的一个问题就是，要正确理解什么是“抖动”，抖动存在很多地方，一个随机种子，不同的列的顺序，行的顺序，线上线下数据集等。你所期望的结果，一般需要考虑以下数据集中自身存在的抖动收益。<br>最后就是比较重要的代码效率问题了。</p><p>​        一个高效率的运行框架和调试方案。会大大加快你的想法的测试。【大约1min 验证一个特征】</p><h3 id="数据探索-林有夕的分享"><a href="#数据探索-林有夕的分享" class="headerlink" title="数据探索-林有夕的分享"></a>数据探索-林有夕的分享</h3><p>数据探索主要通过一些统计指标来分析数据的分布。观察数据和结果的影响。</p><p>例如观察数值特征的分布，均值，最值等，观察类别特征的频率分布等。以及一些交叉分布，比如平均每个用户看过的广告数之类的。</p><p>一般数据探索有如下几个好处：</p><ol><li>让你更加了解数据的情况。验证是否符合自己所想的逻辑。</li><li>通过观察特征和标签的分布关系。初步验证该特征是否和标签存在明显的关系。（表现在不同标签下，特征分布差异较大），在一些数据量比较大，模型迭代效率较低的场景下，可以通过该方法初步验证特征是否有意义。</li><li>对于比赛后期，大家关于数据现实意义中有道理的特征和方案都尝试差不多的情况下，数据探索就尤其重要了。因为往往最后的提分点都是一些数据固有的特点，而非业务特点。（比如，通过观察你有可能会发现一些采样错误。一些异常数据点（比如地铁停运、极端天气等影响的label）等等。这些单纯靠猜业务是很难想到的。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法竞赛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EDA笔记</title>
      <link href="/2019/08/15/ckmte2myv0000bouddo3qhgma/"/>
      <url>/2019/08/15/ckmte2myv0000bouddo3qhgma/</url>
      
        <content type="html"><![CDATA[<p>控制大小、改变X轴字段方向</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">9</span>,<span class="number">6</span>))</span><br><span class="line">plt.xticks(fontsize=<span class="number">12</span>,rotation=<span class="number">45</span>)</span><br></pre></td></tr></table></figure><p>改变x轴标签：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loc, labels = plt.xticks()</span><br><span class="line">loc, labels = loc, [<span class="string">"not know"</span>, <span class="string">"network"</span>, <span class="string">"WiFi"</span>, <span class="string">"cellular"</span>, <span class="string">"2G"</span>, <span class="string">"3G"</span>, <span class="string">"4G"</span>,<span class="string">"no"</span>]</span><br><span class="line">plt.xticks(loc, labels,fontsize=<span class="number">12</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><p>二分类标签（0，1）分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sns.countplot(train_df[<span class="string">'favorite'</span>].sort_values())</span><br></pre></td></tr></table></figure><p>单个变量（连续或者类别）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sns.distplot(train.revenue)</span><br><span class="line"><span class="comment"># blog</span></span><br></pre></td></tr></table></figure><p>如果连续变量不服从正太分布：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">train[<span class="string">'logRevenue'</span>] = np.log1p(train[<span class="string">'revenue'</span>])</span><br><span class="line">sns.distplot(train[<span class="string">'logRevenue'</span>] )</span><br><span class="line"><span class="comment">#------EDA, Feature Engineering, LGB+XGB+CAT：电影预测比赛</span></span><br></pre></td></tr></table></figure><p>（最后需要变换回来）</p><p>对两个特征的连续变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.jointplot(x=<span class="string">"runtime"</span>, y=<span class="string">"revenue"</span>, data=train, height=<span class="number">11</span>, ratio=<span class="number">4</span>, color=<span class="string">"g"</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#------EDA, Feature Engineering, LGB+XGB+CAT：电影预测比赛</span></span><br></pre></td></tr></table></figure><p>对类别属性：</p><p>单个类别值（按顺序）计数：例如时间类特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">20</span>,<span class="number">12</span>))</span><br><span class="line">sns.countplot(train[<span class="string">'release_month'</span>].sort_values())</span><br><span class="line">plt.title(<span class="string">"Release Month Count"</span>,fontsize=<span class="number">20</span>)</span><br><span class="line">loc, labels = plt.xticks()</span><br><span class="line">loc, labels = loc, [<span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span>, <span class="string">"Apr"</span>, <span class="string">"May"</span>, <span class="string">"Jun"</span>, <span class="string">"Jul"</span>, <span class="string">"Aug"</span>, <span class="string">"Sep"</span>, <span class="string">"Oct"</span>, <span class="string">"Nov"</span>, <span class="string">"Dec"</span>]</span><br><span class="line">plt.xticks(loc, labels,fontsize=<span class="number">20</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment">#----------kaggle_baseline反欺诈算法挑战赛：IEEE</span></span><br></pre></td></tr></table></figure><p>例如二分类问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对正负标签值查看关于某个特征的数值分布</span></span><br><span class="line">plt.figure(figsize=(<span class="number">9</span>,<span class="number">6</span>))</span><br><span class="line">sns.countplot(hue=<span class="string">'label'</span>,x=<span class="string">'ntt'</span>,data=All_data_for_train)</span><br><span class="line">loc, labels = plt.xticks()</span><br><span class="line">loc, labels = loc, [<span class="string">"not know"</span>, <span class="string">"network"</span>, <span class="string">"WiFi"</span>, <span class="string">"cellular"</span>, <span class="string">"2G"</span>, <span class="string">"3G"</span>, <span class="string">"4G"</span>,<span class="string">"no"</span>]</span><br><span class="line">plt.xticks(loc, labels,fontsize=<span class="number">12</span>)</span><br><span class="line"><span class="comment"># plt.xticks(fontsize=12,rotation=45)</span></span><br><span class="line">plt.title(<span class="string">"ntt Count"</span>,fontsize=<span class="number">15</span>)</span><br><span class="line"><span class="comment">#----------2019移动广告反欺诈算法挑战赛</span></span><br></pre></td></tr></table></figure><p>或者，以正负标签为X轴，观察其对另一特征的数值特点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sns.catplot(x=<span class="string">"has_homepage"</span>, y=<span class="string">"revenue"</span>, data=train)</span><br><span class="line">plt.title(<span class="string">'Revenue of movies with and without homepage'</span>)</span><br><span class="line"><span class="comment">#------EDA, Feature Engineering, LGB+XGB+CAT：电影预测比赛</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> EDA </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用GitHub Pages 和 Hexo搭建博客</title>
      <link href="/2019/07/30/ckmte2n0u000sboud8gnqneev/"/>
      <url>/2019/07/30/ckmte2n0u000sboud8gnqneev/</url>
      
        <content type="html"><![CDATA[<h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><hr><p>首先可以看这篇文章<a href="http://jmcglone.com/guides/github-pages/" target="_blank" rel="noopener">在GitHub上创建和托管个人网站</a>，熟悉一下git的基本工作流程以及在GitHub上创建和托管个人网站实施步骤，以便对一些模糊的概念有所理解。熟悉工作流程或者不感兴趣的话可以跳过这一步，并不影响整个博客的搭建。</p><a id="more"></a><ol><li>创建项目的存储库。登录您的GitHub帐户并转到<a href="https://github.com/new" target="_blank" rel="noopener">https://github.com/new</a>，或点击您帐户主页上的新建存储库图标。</li><li>为存储库命名<code>username.github.io</code>，替换<code>username</code>为您的GitHub用户名(命名格式必须严格按照这个)。然后确保它是公开的(Public)，勾选创建README文件选项，然后创建存储库。</li></ol><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><hr><p>环境搭建参考自：<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="noopener">Hexo官方文档</a></p><ol><li><p>安装Git：从其官网下载务必挂代理，没有的话<a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">从这个页面</a>下载存储于百度云的资源。</p></li><li><p>安装Node.js </p><ol><li>对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选<strong>Add to PATH</strong>选项。</li><li>另外，也可以使用<strong>Git Bash</strong>，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，可以考虑始终使用<strong>Git Bash</strong>来进行操作。</li></ol></li><li><p>安装Hexo<br>由于某些大家都知道的缘故，npm官方源在国内的下载速度极其慢，用官网的<code>npm install hexo-cli -g</code>速度非常感人，所以不推荐这种方式。推荐用淘宝的npm分流—cnpm<br><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p><p>之后的用法和npm一样，无非是把<code>npm install</code>改成<code>cnpm install</code>,但是速度比之前快了不止一个数量级。</p></li><li><p>检查：</p><p><code>node -v</code>,<code>git --version</code>,<code>hexo -v</code>。</p></li></ol><blockquote><p>除特殊说明，所有命令行语句都在<code>/d/blog</code>路径下进行，并且只用Git Bash，不要用CMD</p></blockquote><h3 id="本地博客"><a href="#本地博客" class="headerlink" title="本地博客"></a>本地博客</h3><hr><ol><li>任选一位置创建文件夹 blog，在blog文件夹空白处右键选择 <code>Git Bash Here</code>.</li><li>输入 <code>hexo init</code> 将 blog 文件夹初始化成一个博客文件夹。</li><li>输入 <code>npm install</code> —&gt;安装依赖包。</li><li>输入 <code>hexo g</code>  —&gt;生成运行环境。 </li><li>输入 <code>hexo s</code> 将生成的网页放在了本地服务器（server）。</li><li>浏览器里输入 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> , 就可以看到刚才的成果了。</li><li>回到 Git Bash，按 Ctrl+C 终止本地服务器。</li></ol><h3 id="部署到-Github-上"><a href="#部署到-Github-上" class="headerlink" title="部署到 Github 上"></a>部署到 Github 上</h3><ol><li><p>获取 Github 对应存储库(即你创建的username.github.io)的链接。<br>eg：<a href="https://github.com/lwhluvdemo/lwhluvdemo.github.io.git" target="_blank" rel="noopener">https://github.com/lwhluvdemo/lwhluvdemo.github.io.git</a></p></li><li><p>修改博客的配置文件<br>打开blog文件夹下的<code>_config.yml</code>文件(我自己用的是ultraEdit,VS code、notepad++等也可以)<br>找到 <code>#Deployment</code>，填入以下内容：</p><blockquote><p>这里要注意，凡是修改配置文件，<strong>属性名的冒号后面一定要有一个空格才能加属性值</strong>，不然会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: https://github.com/lwhluvdemo/lwhluvdemo.github.io.git<span class="comment">## 用第一步得到的链接</span></span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>回到 Git Bash，输入 <code>npm install hexo-deployer-git --save</code> 安装 hexo-deployer-git 此步骤只需要做一次。</p></li><li><p>输入 <code>hexo d</code>，得到 <code>INFO Deploy done: git</code> 即为部署成功。</p><p>之后写博文常用<code>hexo g -d</code>部署。</p><blockquote><p>可以使用<code>hexo clean</code>命令来清除缓存，也就是删除<code>.public</code>文件夹，如果以后出现一些看不懂的bug，可以试试先clean再重新<code>hexo g</code>也许可以解决。</p></blockquote></li></ol><h3 id="新建博文"><a href="#新建博文" class="headerlink" title="新建博文"></a>新建博文</h3><hr><p>我们的<code>.md</code>博文都存放在<code>..\blog\source\_posts</code>目录下，我们可以通过删除本地文件重新部署的方式来删除博文，当然也可以新建一个md文件。</p><p>另一种是用命令行新建，打开GitBash输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">"文章标题"</span></span><br></pre></td></tr></table></figure><p>在_posts文件夹中找到刚刚新建的md文件，里面有</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 创建文章的时间</span><br><span class="line">tags: 文章标签</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p>对上面的内容进行修改，或者直接开始往下写，写完保存之后，通过<code>hexo g</code>、<code>hexo d</code>来更新你的博客。</p><h3 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h3><hr><p>到<a href="https://hexo.io/themes/" target="_blank" rel="noopener">官方主题站</a>搜索自己喜欢的主题，都附有配置解释文档的以及使用方式</p><p>安装主题的统一方式是，打开GitBash：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone 主题GitHub仓库地址 themes/主题名</span><br></pre></td></tr></table></figure><p>打开 D:/blog/_config.yml文件，在一般在倒数第6，7行，找到<code>theme:</code>,后面的内容改为代码行里的<code>主题名</code>。</p><p>找到 <code># Site</code>，添加博客名称，作者名字等。</p><p>在 <code>language</code> 后面填入 en 或者 zh-CN，选择英文或者中文。(一般在<code>..\blog\themes\主题名\languages</code>里可以看到主题支持的语言)</p><p>找到 <code># URL</code>, 填入 url。比如 <code>url: https://lwhluvdemo.github.io/</code>。</p><p>在GitBash重新生成部署：<code>hexo g -d</code>.</p><h3 id="为博客选择图床"><a href="#为博客选择图床" class="headerlink" title="为博客选择图床"></a>为博客选择图床</h3><hr><p>给博文配图：</p><ol><li>把图片存放到相应的资源文件夹，随博客一起部署到GitHub</li><li>通过利用Markdown语法给博文添加图片链接，在观看博文的时候在线加载图片。</li></ol><h3 id="博客写作"><a href="#博客写作" class="headerlink" title="博客写作"></a>博客写作</h3><hr><h4 id="Fancybox图片预览"><a href="#Fancybox图片预览" class="headerlink" title="Fancybox图片预览"></a>Fancybox图片预览</h4><p>将需要放大预览的图片用<code>&lt;fancybox&gt; &lt;/fancybox&gt;</code>包含起来。</p><h4 id="一行显示多图"><a href="#一行显示多图" class="headerlink" title="一行显示多图"></a>一行显示多图</h4><p>将多个图片同时放在一对<code>&lt;fancybox&gt; &lt;/fancybox&gt;</code>中即可</p><h4 id="颜文字"><a href="#颜文字" class="headerlink" title="颜文字"></a>颜文字</h4><p><a href="https://spacekid.me/kaomoji/" target="_blank" rel="noopener">太空小孩</a>。</p><p><a href="http://www.yanwenzi.com/changyong/" target="_blank" rel="noopener">颜文字</a>.</p><h4 id="emoji表情"><a href="#emoji表情" class="headerlink" title="emoji表情"></a>emoji表情</h4><p><a href="http://emojihomepage.com/" target="_blank" rel="noopener">Emoji Homepage</a>.</p><p><a href="https://www.jianshu.com/p/e66c9a26a5d5" target="_blank" rel="noopener">Markdown玩转Emoji</a>.</p><h4 id="图片带链接："><a href="#图片带链接：" class="headerlink" title="图片带链接："></a>图片带链接：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![alt text](http://path/to/img.jpg "title")](你的链接地址)</span><br></pre></td></tr></table></figure><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>设置<code>gitalk.id</code>实现多个页面共用一个评论框</p><p>在文章的Front-matter中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">gitalk:</span><br><span class="line">  id: /wiki/material-x/</span><br><span class="line">---</span><br></pre></td></tr></table></figure><h4 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h4><p>见<a href="https://xaoxuu.com/wiki/material-x/front-matter/index.html" target="_blank" rel="noopener">官方文档</a>.</p><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><blockquote><p><a href="https://xaoxuu.com/wiki/vim-cn.sh//" target="_blank" rel="noopener">vim-cn.sh</a>.是一个十分干净好用的图床，本站以及博客中的所有图片都是使用的这个图床。所以，这是一个快速批量<strong>上传图片</strong>的脚本。（勿滥用）</p></blockquote><h3 id="关于添加评论插件和设置个性化域名遇到的错误"><a href="#关于添加评论插件和设置个性化域名遇到的错误" class="headerlink" title="关于添加评论插件和设置个性化域名遇到的错误"></a>关于添加评论插件和设置个性化域名遇到的错误</h3><hr><p>要设置个性化域名，为自己的域名做这些设置（为gitalk评论插件做准备）<img src="https://img.vim-cn.com/9c/76a0e975954ba7777552998278f695839ac226.png" alt>，然后从GitHub的博客存储库的设置最下面<code>Custom domain</code>填入自己的域名（我自己的是<code>lwhluvdemo.ml</code>），再在本地博客根目录的<code>source</code>下新建一个无后缀CNAME文件填入自己的个性域名，否则每次<code>hexo g -d</code>都会重置。</p><p>GitHub个人主页Settings-&gt;Developer settings-&gt;OAuth Apps，具体可以参考这个文档的</p><p><a href="https://xaoxuu.com/wiki/material-x/third-party-services/index.html" target="_blank" rel="noopener">Gitalk</a>，获得建立评论区<code>clientID</code>和<code>clientSecret</code>，之后在<code>Homepage URL</code>填自己博客的地址，例如我的博客：<a href="https://lwhluvdemo.github.io/">https://lwhluvdemo.github.io/</a></p><p>以及<code>Authorization callback URL</code>填写自己的域名地址，例如我的域名：<a href="https://lwhluvdemo.ml/" target="_blank" rel="noopener">https://lwhluvdemo.ml/</a>.</p><p>两个地址后面都要加 <strong>/</strong>。</p><p><strong>如果前面是按照我的设置来的话，一般不会有hexo配置gitalk 评论后无法初始化创建issue的问题</strong></p><h4 id="解决Error-Validation-Failed错误"><a href="#解决Error-Validation-Failed错误" class="headerlink" title="解决Error: Validation Failed错误"></a>解决Error: Validation Failed错误</h4><p>最后是根目录下<code>_config.yml</code>配置文件的改变，主要是将<code>permalink</code>的title变为id来避免超过50个字符的限制</p><blockquote><p>网上流传的很流行的md5方法等，我。。。。一个也不会用，主要是他们说的在哪哪添加文件，我根本就没有那些路径，所以想用也没办法。</p><p><a href="https://github.com/gitalk/gitalk/issues/102" target="_blank" rel="noopener">大部分与MD5相关的答案可以从这里找到</a>。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span><br><span class="line">url: https://lwhluvdemo.github.io</span><br><span class="line">root: /</span><br><span class="line">permalink: :year/:month/:day/:id/</span><br><span class="line">permalink_defaults:</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gitalk:</span><br><span class="line">  clientID: **************</span><br><span class="line">  clientSecret: ***********************</span><br><span class="line">  repo: yourname.github.io</span><br><span class="line">  owner: yourname</span><br><span class="line">  admin: [yourname]</span><br><span class="line">  id: decodeURI(window.location.pathname)</span><br></pre></td></tr></table></figure><p>一般提交后需要几分钟来重新部署，立刻刷新网页不会变……等等就好。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> GitHub Pages </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
