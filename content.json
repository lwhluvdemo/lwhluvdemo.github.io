{"meta":{"title":"水上书呀","subtitle":"君子慎独","description":"个人博客","author":"lwhluvdemo","url":"https://lwhluvdemo.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-07-31T06:44:12.065Z","updated":"2019-07-31T06:44:12.065Z","comments":true,"path":"about/index.html","permalink":"https://lwhluvdemo.github.io/about/index.html","excerpt":"","text":"[][1] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][2] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][3] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [][4] 现在是一个大学生，就读于南京农业大学交通运输专业，喜欢码代码，热衷于机器学习方面的探索，虽然现在还不是很强，但会一直坚持下去的，欢迎各位找我一块组队打比赛呀。 另外，我还喜欢各种风格的纯音乐，喜欢看番，所以......JOJO天下第一。 :kissing_closed_eyes::stuck_out_tongue::smile::full_moon_with_face: 欢迎留言～"},{"title":"我的朋友们","date":"2019-07-31T06:10:33.607Z","updated":"2019-07-31T06:10:33.607Z","comments":true,"path":"friends/index.html","permalink":"https://lwhluvdemo.github.io/friends/index.html","excerpt":"","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～ 名称： xaoxuu’s blog头像： https://img.vim-cn.com/76/c339fd7092750f472da9ad17bd7c0081a1f0e2.jpg网址： https://xaoxuu.com/blog/标签： iOS"}],"posts":[{"title":"教程1","slug":"教程1","date":"2019-10-19T14:53:39.000Z","updated":"2019-10-19T15:08:29.729Z","comments":true,"path":"2019/10/19/ck1xpgjah0000xoudi9wduup5/","link":"","permalink":"https://lwhluvdemo.github.io/2019/10/19/ck1xpgjah0000xoudi9wduup5/","excerpt":"","text":"教程vscode教程（基础篇）. Google Colab 免费 GPU 使用教程， 始于Jupyter Notebooks：一份全面的初学者实用指南, 这篇文章最后的部分： 这个 GitHub 库包含了一些有趣迷人的 Jupyter Notebooks：（https://github.com/jupyter/jupyter/wiki/A-gallery-of-interesting-Jupyter-Notebooks），这个链接很详细 matplotlib - 2D and 3D plotting in Python.—-&gt;一个很酷的可视化教程 makedown教程. 正则表达式 廖雪峰正则表达式教程。 正则化教程(字典式)，——&gt;测试地址(https://tool.lu/regex/) 深入：microsoft/computerscience： 微软：针对教师，学生和开发者的免费技术资源，可用于计算机科学课程，研讨会和黑客马拉松。 利用Python进行数据分析·第2版， 拓展：GitHub：这是广大开发者们的圣地与乐园，GitHub 上除了有各大科技公司的顶级开源项目，也活跃着众多具有业界影响力的开源先锋们，而在去年 11 月，GitHub 的仓库数量已经突破了一个亿。但事实上，除了正儿八经的开源项目，GitHub 上还有许多令人哭笑不得的开源项目，看完以后你会发现，原来 GitHub 还可以这样玩。 Stackoverflow： 编程新手如何提高编程能力？. 为什么程序员在学习编程的时候什么都记不住？.","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://lwhluvdemo.github.io/tags/python/"},{"name":"协会新手教程","slug":"协会新手教程","permalink":"https://lwhluvdemo.github.io/tags/协会新手教程/"}]},{"title":"闲聊","slug":"毕业找工作的建议","date":"2019-10-02T14:53:39.000Z","updated":"2019-10-19T13:36:31.574Z","comments":true,"path":"2019/10/02/ck1xpgjcc0005xoud91k1364r/","link":"","permalink":"https://lwhluvdemo.github.io/2019/10/02/ck1xpgjcc0005xoud91k1364r/","excerpt":"From：全部来自CVer群里“Leo林”大佬的一些闲聊 这里好像不少毕业找工作的，说一些建议吧: 充分评估自己的能力，不要总想着 BAT 这样的大公司。大公司人才济济，说实话，除非天才类型，否则各个位置上都占好了坑，要上位不容易的。大多数毕业生都是大公司用来筛选的基数，给你个 2年高工资无所谓，但一般半年后就开始见分晓，该转岗去填劳力的就强制转，不转的话看你是想去哪？拿着高薪不做事？一般降薪比较难操作，直接开掉比较容易。开老员工容易伤感情，赔偿还多，开工作一两年就简单很多。总之呢，大公司高薪找毕业生其实是一种大撒网策略，不要真以为就是自己值这个钱。","text":"From：全部来自CVer群里“Leo林”大佬的一些闲聊 这里好像不少毕业找工作的，说一些建议吧: 充分评估自己的能力，不要总想着 BAT 这样的大公司。大公司人才济济，说实话，除非天才类型，否则各个位置上都占好了坑，要上位不容易的。大多数毕业生都是大公司用来筛选的基数，给你个 2年高工资无所谓，但一般半年后就开始见分晓，该转岗去填劳力的就强制转，不转的话看你是想去哪？拿着高薪不做事？一般降薪比较难操作，直接开掉比较容易。开老员工容易伤感情，赔偿还多，开工作一两年就简单很多。总之呢，大公司高薪找毕业生其实是一种大撒网策略，不要真以为就是自己值这个钱。 目前人工智能在风头上，但今年产业发展已经开始回归理性，大多数公司在讨论的是怎么落地。这个时候大公司给高工资招的算法，一到两年内冷下来之后就很危险。大公司也不是做慈善的，不会养一批人做纯研究的。如果在公司做的算法和产品脱离了，自己就真要当心想一想了。不讲业绩的部门，也就不受重视，自己前途如何，要心里有数。做研究类的算法，真正能转化为产品的应该不会高于30%。等风口冷下来了，也是大公司就高薪酬年轻人动刀的 时候了 大公司每年招那么多人，其实就和鲸鱼差不多，先把鱼虾海水啥的都吞进来，然后再过滤掉，那一两年的工资差负担的起。否则为啥每年招那么多毕业生公司还在不停的招，真的是业务发展的需求？看看公司每年的增长率是多少就知道了。拿高薪人人都想，但是真的要搞清楚自己是不是准备被过滤掉的那批。2年后再出来，风口已过，到处都是被大公司筛出来的，还要和应届生再竞争了 真的是不是白菜价只有公司内部知道，如果凭着风口和老员工薪酬倒挂，那就更危险。要调老员工是大规模的调，公司受不了的，那如果短时间内没有做出大的贡献或者证明不了自己，看公司是情愿把所有的老员工薪酬调的和你一样，还是直接把你开了简单？ 2年跳一次，到底是能力问题还是态度问题呀？到底是被开的还是自己辞职的呀？HR 冒不起这个风险呀跳了以后，除非是行业内大牛，在新公司又要花个几年去铺垫才能上位，上不了位就只能一直待在某一个层级，10年工作还没有进展，以后基本就这样层次了 公司招人进来，HR 都是会评估的。这个人未来是否可以长期培养，是否资源和态度方面可以向他倾斜，这些都是你背后一只看不见的手。如果定位是招进来干2年活，做做事情，那也不需要花太多精力去照顾，反正迟早要走的 不是劝退，只是想说，不要只看着大公司的高薪酬。要评估一下自己的能力，是否技术和能力真的好，能在大公司和全国的人才拼一拼。如果自己是 20% 以下的，有比较靠谱的中型公司，有明确的技术前景，也可以考虑。潜心做几年，中小公司反而比较愿意花精力培养新人，当然前提是真的研发为核心的技术公司，而不是贸易公司。 每个人有每个人的造化，中小型公司也有风险。总得来说运气比实力占的比重大。工作以后也不单看技术，还要看沟通能力。能否把自己做的事情讲出来。只会技术讲不出来的，安安静静做个技术型专家也未尝不可。会技术又能讲得出来的，可以往技术领头人方向走。嘴皮子比较厉害，无心做技术的，做两年最好就考虑转方向 进了大公司的，头一年要保持些敏感度，和周边的人对比一下，看看自己是否真的有竞争力，一年内主动走的，下家企业基本是能按毕业生的角度来看的。2年后再走的，一般就按社招来判断了，会比较关心你跳槽的原因是什么了 转哪里就看自己的优势所在了，技术精英总归是少数，做个非精英部队的头部也不错的。如果工作了两年还没搞清楚自己的优势所在，我觉得最好就找个咨询公司帮忙做一下自己的职业规划做个参考。现在好像也蛮多这样的服务的，花点钱值得 另外，有一个错觉是大公司学技术会比较好，其实大公司大多流程化，长时间可能就只能做一小块事情的。要转岗跳项目组多少有些忌讳。中小公司反而因为缺人，很快就要负责很多事情，累肯定累，但学得东西也多。长远来说，这方面倒是比薪酬其实带来的价值会更大一些","categories":[],"tags":[{"name":"工作","slug":"工作","permalink":"https://lwhluvdemo.github.io/tags/工作/"}]},{"title":"双指针","slug":"双指针","date":"2019-09-19T08:53:39.000Z","updated":"2019-09-20T09:36:50.407Z","comments":true,"path":"2019/09/19/ck0qvueuw0009bwudi4cds354/","link":"","permalink":"https://lwhluvdemo.github.io/2019/09/19/ck0qvueuw0009bwudi4cds354/","excerpt":"26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。","text":"26. 删除排序数组中的重复项给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。 不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。 示例 1: 12345给定数组 nums = [1,1,2], 函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。 题目要求两件事： 统计数组中不同数字数量 $k$ ； 修改数组前 $k$ 个元素为这些不同数字。 算法流程： 第一个指针 $i$ ： 由于数组已经完成排序，因此遍历数组，每遇到 $nums[i] \\not= nums[i - 1]$，就说明遇到了新的不同数字，记录之； 第二个指针 $k$ ： 每遇到新的不同数字时，执行$k+=1$ ，$k$ 指针有两个作用： 记录数组中不同数字的数量； 作为修改数组元素的索引index。 最终，返回 $k$ 即可。 解答：123456789class Solution: def removeDuplicates(self, nums: List[int]) -&gt; int: if not nums:return 0 k = 1 for i in range(1,len(nums)): if nums[i] != nums[i-1]: nums[k] = nums[i] k += 1 return k 复杂度分析 时间复杂度：$O(n)$，假设数组的长度是 $n$，那么 $i$ 和 $j$ 分别最多遍历 $n$ 步。 空间复杂度：$O(1)$。 88. 合并两个有序数组给定两个有序整数数组 nums1 和 nums2，将 nums2 合并到 nums1 中，使得 num1 成为一个有序数组。 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素 示例： 12345输入:nums1 = [1,2,3,0,0,0], m = 3nums2 = [2,5,6], n = 3输出: [1,2,2,3,5,6] 解法一：双指针 / 从前往后一般而言，对于有序数组可以通过 双指针法 达到$O(n + m)$的时间复杂度。 最直接的算法实现是将指针p1 置为 nums1的开头， p2为 nums2的开头，在每一步将最小值放入输出数组中。 由于 nums1 是用于输出的数组，需要将nums1中的前m个元素放在其他地方，也就需要 $O(m)$ 的空间复杂度。 1234567891011121314151617181920212223242526272829303132class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" # Make a copy of nums1. nums1_copy = nums1[:m] nums1[:] = [] # Two get pointers for nums1_copy and nums2. p1 = 0 p2 = 0 # Compare elements from nums1_copy and nums2 # and add the smallest one into nums1. while p1 &lt; m and p2 &lt; n: if nums1_copy[p1] &lt; nums2[p2]: nums1.append(nums1_copy[p1]) p1 += 1 else: nums1.append(nums2[p2]) p2 += 1 # if there are still elements to add if p1 &lt; m: nums1[p1 + p2:] = nums1_copy[p1:] if p2 &lt; n: nums1[p1 + p2:] = nums2[p2:] 复杂度分析 时间复杂度 : $O(n + m)$。 空间复杂度 : $O(m)$。 解法二 : 双指针 / 从后往前123456789101112131415161718192021222324252627class Solution(object): def merge(self, nums1, m, nums2, n): \"\"\" :type nums1: List[int] :type m: int :type nums2: List[int] :type n: int :rtype: void Do not return anything, modify nums1 in-place instead. \"\"\" # two get pointers for nums1 and nums2 p1 = m - 1 p2 = n - 1 # set pointer for nums1 p = m + n - 1 # while there are still elements to compare while p1 &gt;= 0 and p2 &gt;= 0: if nums1[p1] &lt; nums2[p2]: nums1[p] = nums2[p2] p2 -= 1 else: nums1[p] = nums1[p1] p1 -= 1 p -= 1 # add missing elements from nums2 nums1[:p2 + 1] = nums2[:p2 + 1] 复杂度分析 时间复杂度 : $O(n + m)$。 空间复杂度 : $O(1)$。 125. 验证回文串给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 : 12输入: \"A man, a plan, a canal: Panama\"输出: true 解法：思路： 设置一个头指针和一个尾指针 头指针从头开始找，找到第一个数字或字符 尾指针从尾开始找，找到最后一个数字或字符 比较两者是否相同，不同就return False 相同则两指针往中间靠 当 i &gt; j 的时候，return True 1234567891011121314151617class Solution: def isPalindrome(self, s: str) -&gt; bool: i, j = 0, len(s) - 1 while i &lt; j: # isalnum() 方法检测字符串是否由字母和数字组成 while i &lt; len(s) and not s[i].isalnum(): i += 1 while j &gt; -1 and not s[j].isalnum(): j -= 1 if i &gt; j: return True if s[i].upper() != s[j].upper(): return False else: i += 1 j -= 1 return True 复杂度分析 时间复杂度 O(N), 遍历一遍数组。 空间复杂读 O(1)，只使用了常量的空间。 同思想另一种写法： 1234567891011121314151617class Solution: def isPalindrome(self, s: str) -&gt; bool: l = 0 r = len(s)-1 while l &lt; r: if s[l].isalnum() and s[r].isalnum(): if s[l].upper() == s[r].upper(): l += 1 r -= 1 else: return False else: if not s[l].isalnum(): l += 1 if not s[r].isalnum(): r -= 1 return True 其他解法： 123456class Solution: def isPalindrome(self, s: str) -&gt; bool: return (\"\".join(filter(str.isalnum, s)).lower()[::-1]) == (\"\".join(filter(str.isalnum, s)).lower())########分开写s = \"\".join(filter(str.isalnum, s)).lower()return s[::-1] == s 141. 环形链表给定一个链表，判断链表中是否有环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 示例 1： 123输入：head = [3,2,0,-4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。 解法一： 设两指针fast slow指向链表头部head，迭代： fast每轮走两步，slow每轮走一步，这样两指针每轮后距离+1; 若链表中存在环，fast和slow一定会在将来相遇（距离连续+1，没有跳跃）； 若fast走到了链表尾部，则说明链表无环。 12345678class Solution(object): def hasCycle(self, head): fast, slow = head, head while fast and fast.next: fast = fast.next.next slow = slow.next if fast == slow: return True return False 解法二：通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表 123456789101112131415class Solution(object): def hasCycle(self, head): \"\"\" :type head: ListNode :rtype: bool \"\"\" save = set() cur = head while cur is not None: if cur in save: return True else: save.add(cur) cur = cur.next return False","categories":[],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://lwhluvdemo.github.io/tags/数据结构与算法/"}]},{"title":"","slug":"比赛群学习笔记","date":"2019-09-12T13:31:39.922Z","updated":"2019-09-12T13:31:39.922Z","comments":true,"path":"2019/09/12/ck0qvueuy000abwudqr0bfamb/","link":"","permalink":"https://lwhluvdemo.github.io/2019/09/12/ck0qvueuy000abwudqr0bfamb/","excerpt":"","text":"比赛群学习笔记如果某个特征很强很强，那么原样拷贝一下，构造一个新的特征。会怎样？ 分裂次数，首先，每个特征复杂度不同。。自身能分裂的次数就是不定的。 道理上，这样普遍情况下肯定没用。但是两个特征肯定会有原特征一半左右的特征重要性，那么这个表面看，还是强特呢 我看的这个链接，按照林佬的讲法，这个feature-selector有些思路也是有问题的，我觉得我也要再想想想，模型只有学到，在测试集中依旧有用的信息，才有价值，构建好一致的线下验证集，是成功的一半，其实影响得分最大的因素是验证数据 线下5折的时候。每折的得分的方差大，还是同一个折，换不同的5个种子的方差大？其实很明显是前者。 绝大部分误差是数据真实标签带来的。。一般说的线下线上一致，都是指增减一致。而不是分数接近。","categories":[],"tags":[]},{"title":"pandas技巧","slug":"pandas技巧","date":"2019-09-05T14:53:39.000Z","updated":"2019-09-19T16:03:44.135Z","comments":true,"path":"2019/09/05/ck0qvueur0005bwudbe8qpzy1/","link":"","permalink":"https://lwhluvdemo.github.io/2019/09/05/ck0qvueur0005bwudbe8qpzy1/","excerpt":"用一列的非空值填充另一列对应行的空值12# 利用数据框df的name列中的非空值，去填充df的features_1列中对应的NaN。df.loc[df['features_1'].isnull(),'features_1']=df[df['features_1'].isnull()][‘name’]","text":"用一列的非空值填充另一列对应行的空值12# 利用数据框df的name列中的非空值，去填充df的features_1列中对应的NaN。df.loc[df['features_1'].isnull(),'features_1']=df[df['features_1'].isnull()][‘name’] 填充缺失值123456789101112131415#填充缺失值for i in string_feature+other_feature: mode_num = data[i].mode()[0] if (mode_num != -1): print(i) data.loc[data[i] == -1, i] = mode_num else: print(-1)for i in numeric_feature: mean_num = data[i].mean() if (mean_num != -1): print(i) data.loc[data[i] == -1, i] = mean_num else: print(-1) 判断两个list是否是父子集关系 12345a = [1,2]b = [1,2,3]c = [0, 1]set(b) &gt; set(a)set(b) &gt; set(c) 求列表差值： 1list(set(a).difference(set(b))) 按列时间值筛选 Pandas DataFrame 123import pandas as pdimport numpy as npimport io 12345678910t=\"\"\"2015-01-01 04:00:002015-01-01 05:00:002015-01-01 06:00:002015-01-01 07:00:002015-01-02 04:00:002015-01-02 05:00:002015-01-02 06:00:002015-01-02 07:00:00\"\"\"s = pd.read_csv(io.StringIO(t), parse_dates=[0], header=None, names=['date'])s[(s['date'].dt.hour &lt;= 6)&amp;(s['date'].dt.hour &gt;= 2)] 计算真值 1np.count_nonzero(df[col].value_counts().reset_index()[col].values&gt;=600) 每列的最大值： 1train_df.ix[train_df.idxmax()].iloc[:,60:120].max() 同类特征正则匹配： 123456789# 同类特征正则匹配测试df = pd.DataFrame(np.array(([1, 2, 3,4,4,4,4,8,8,8], [4, 5, 6,5,5,5,5,7,7,7])), index=['mouse', 'rabbit'], columns=['WebInfo_1', 'WebInfo_2', 'WebInfo_3','ProductInfo_1', 'ProductInfo_2','ProductInfo_3','ProductInfo_4','UserInfo_1', 'UserInfo_2','UserInfo_3'])df_WebInfo = df.filter(regex=\"WebInfo_\\d&#123;1,3&#125;\")df_ProductInfo = df.filter(regex=\"ProductInfo_\\d&#123;1,3&#125;\")df_UserInfo = df.filter(regex=\"UserInfo_\\d&#123;1,3&#125;\") 将一列的值填充到另一列同行的缺失值中 12train.loc[train['member_id'].isnull(),'member_id'] = train[train['member_id'] .isnull()]['customer_id']","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://lwhluvdemo.github.io/tags/机器学习/"},{"name":"pandas","slug":"pandas","permalink":"https://lwhluvdemo.github.io/tags/pandas/"}]},{"title":"keras_bert","slug":"keras_bert","date":"2019-08-29T14:53:39.000Z","updated":"2019-09-19T16:05:14.521Z","comments":true,"path":"2019/08/29/ck0qvueuf0002bwud6dy0qyfu/","link":"","permalink":"https://lwhluvdemo.github.io/2019/08/29/ck0qvueuf0002bwud6dy0qyfu/","excerpt":"keras_bert分类示例中在IMDB数据集上对模型进行了微调以适应新的分类任务。 12345# 会下载Bert模型!pip install -q keras-bert keras-rectified-adam!wget -q https://storage.googleapis.com/bert_models/2018_10_18/uncased_L-12_H-768_A-12.zip# !wget -q https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip # 中文!unzip -o uncased_L-12_H-768_A-12.zip","text":"keras_bert分类示例中在IMDB数据集上对模型进行了微调以适应新的分类任务。 12345# 会下载Bert模型!pip install -q keras-bert keras-rectified-adam!wget -q https://storage.googleapis.com/bert_models/2018_10_18/uncased_L-12_H-768_A-12.zip# !wget -q https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip # 中文!unzip -o uncased_L-12_H-768_A-12.zip 1234567# 加载路径import ospretrained_path = 'chinese_L-12_H-768_A-12'config_path = os.path.join(pretrained_path, 'bert_config.json')checkpoint_path = os.path.join(pretrained_path, 'bert_model.ckpt')vocab_path = os.path.join(pretrained_path, 'vocab.txt') 第二种方式123456from keras_bert.datasets import get_pretrained, PretrainedListmodel_path = get_pretrained(PretrainedList.chinese_base)paths = get_checkpoint_paths(model_path)model = load_trained_model_from_checkpoint(paths.config, paths.checkpoint, seq_len=10)model.summary(line_length=120)token_dict = load_vocabulary(paths.vocab) 123456789tokenizer = Tokenizer(token_dict)text = '语言模型'tokens = tokenizer.tokenize(text)print('Tokens:', tokens)indices, segments = tokenizer.encode(first=text, max_len=10)predicts = model.predict([np.array([indices]), np.array([segments])])[0]for i, token in enumerate(tokens): print(token, predicts[i].tolist()[:5]) tensorboard 可视化训练过程1234567891011121314151617181920212223from tensorflow.python import kerasfrom kashgari.tasks.classification import BiGRU_Modelfrom kashgari.callbacks import EvalCallBackimport logginglogging.basicConfig(level='DEBUG')model = BiGRU_Model()tf_board_callback = keras.callbacks.TensorBoard(log_dir='./logs', update_freq=1000)# 这是 Kashgari 内置回调函数，会在训练过程计算精确度，召回率和 F1eval_callback = EvalCallBack(kash_model=model, valid_x=valid_x, valid_y=valid_y, step=5)# model = CNNModel()model.fit(train_x, train_y, val_x, val_y, batch_size=100, callbacks=[eval_callback, tf_board_callback]) 在项目目录运行下面代码即可启动 tensorboard 查看可视化效果 1$ tensorboard --log-dir logs","categories":[],"tags":[{"name":"keras","slug":"keras","permalink":"https://lwhluvdemo.github.io/tags/keras/"},{"name":"bert","slug":"bert","permalink":"https://lwhluvdemo.github.io/tags/bert/"}]},{"title":"数据结构与算法","slug":"数据结构与算法","date":"2019-08-23T01:29:39.000Z","updated":"2019-09-19T08:54:56.665Z","comments":true,"path":"2019/08/23/ck0qvueuu0007bwud4z2vjuny/","link":"","permalink":"https://lwhluvdemo.github.io/2019/08/23/ck0qvueuu0007bwud4z2vjuny/","excerpt":"","text":"大O大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时， O(log n)的速度比O(n)快得多。 散列函数“将输入映射到数字”。 模拟映射关系； 防止重复； 缓存/记住数据，以免服务器再通过处理来生成它们。","categories":[],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://lwhluvdemo.github.io/tags/数据结构/"}]},{"title":"pyspark","slug":"pyspark","date":"2019-08-22T07:43:24.000Z","updated":"2019-08-22T07:47:17.756Z","comments":true,"path":"2019/08/22/ck0qvueus0006bwud3ys6lkfx/","link":"","permalink":"https://lwhluvdemo.github.io/2019/08/22/ck0qvueus0006bwud3ys6lkfx/","excerpt":"","text":"123456from pyspark import SparkConf, SparkContextfrom pyspark.sql import SparkSession,SQLContext,DataFrame,Rowspark= SparkSession.builder.master('local').appName('test').getOrCreate()sc = spark.sparkContextlines = sc.textFile(\"data.txt\") 相关操作：PySpark之RDD入门.","categories":[],"tags":[{"name":"pyspark","slug":"pyspark","permalink":"https://lwhluvdemo.github.io/tags/pyspark/"}]},{"title":"算法竞赛一些问题总结","slug":"算法竞赛笔记","date":"2019-08-20T14:53:39.000Z","updated":"2019-09-19T16:05:50.502Z","comments":true,"path":"2019/08/20/ck0qvuev1000cbwuduf1l49un/","link":"","permalink":"https://lwhluvdemo.github.io/2019/08/20/ck0qvuev1000cbwuduf1l49un/","excerpt":"L1和L2范数都是用来避免过拟合问题，那么请问在使用的时候二者有何区别呢？ L1范数是对系数绝对值之和的约束。梯度会比较陡，通过求导可以知道，当某些特征作用不大的时候，会使得对应的系数为0，主要用于稀疏特征的约束，比如one-hot编码。 L2范数是对系数平方和的约束，从而简化模型。梯度会比较缓，通过求导可以知道，系数很难达到0，因此L2范数不仅能够简化模型，也不会像L1范数一样，迫使模型忽略某些特征，一般来说，如果特征不是很稀疏，可以使用L2。 L1正则假设参数符合拉普拉斯分布，L2正则假设参数符合正态分布。从梯度来看，L2正则对数值大的参数惩罚大，对数值小的参数惩罚小，而L1对参数的惩罚恒定。于是L1容易把不太重要的特征的参数“惩罚”到0，从而产生稀疏的解。","text":"L1和L2范数都是用来避免过拟合问题，那么请问在使用的时候二者有何区别呢？ L1范数是对系数绝对值之和的约束。梯度会比较陡，通过求导可以知道，当某些特征作用不大的时候，会使得对应的系数为0，主要用于稀疏特征的约束，比如one-hot编码。 L2范数是对系数平方和的约束，从而简化模型。梯度会比较缓，通过求导可以知道，系数很难达到0，因此L2范数不仅能够简化模型，也不会像L1范数一样，迫使模型忽略某些特征，一般来说，如果特征不是很稀疏，可以使用L2。 L1正则假设参数符合拉普拉斯分布，L2正则假设参数符合正态分布。从梯度来看，L2正则对数值大的参数惩罚大，对数值小的参数惩罚小，而L1对参数的惩罚恒定。于是L1容易把不太重要的特征的参数“惩罚”到0，从而产生稀疏的解。 比赛做特征工程是一个一个特征加进去试试比较好，还是先做完一堆特征然后再挑比较好？​ 首先要大致清楚模型能学到什么样的特征。 ​ 然后当你做一个特征的时候，你要想清楚为什么这样尝试？为什么你认为这个特征有用，比如，以前的类似比赛用过类似的特征；通过对业务的理解进行推理出来的；通过数据观察(EDA)，发现该特征下，label的表现差异比较大（如果特征是随机数的时候，label理论上差异是最小的），一个具有良好依据的特征解释，是特征有效的根本。 ​ 最直接有效的特征验证的方法就是代入模型验证，所以一个合理的验证策略变得极为重要。这里一定要留意的一个问题就是，要正确理解什么是“抖动”，抖动存在很多地方，一个随机种子，不同的列的顺序，行的顺序，线上线下数据集等。你所期望的结果，一般需要考虑以下数据集中自身存在的抖动收益。最后就是比较重要的代码效率问题了。 ​ 一个高效率的运行框架和调试方案。会大大加快你的想法的测试。【大约1min 验证一个特征】 数据探索-林有夕的分享数据探索主要通过一些统计指标来分析数据的分布。观察数据和结果的影响。 例如观察数值特征的分布，均值，最值等，观察类别特征的频率分布等。以及一些交叉分布，比如平均每个用户看过的广告数之类的。 一般数据探索有如下几个好处： 让你更加了解数据的情况。验证是否符合自己所想的逻辑。 通过观察特征和标签的分布关系。初步验证该特征是否和标签存在明显的关系。（表现在不同标签下，特征分布差异较大），在一些数据量比较大，模型迭代效率较低的场景下，可以通过该方法初步验证特征是否有意义。 对于比赛后期，大家关于数据现实意义中有道理的特征和方案都尝试差不多的情况下，数据探索就尤其重要了。因为往往最后的提分点都是一些数据固有的特点，而非业务特点。（比如，通过观察你有可能会发现一些采样错误。一些异常数据点（比如地铁停运、极端天气等影响的label）等等。这些单纯靠猜业务是很难想到的。","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://lwhluvdemo.github.io/tags/机器学习/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"https://lwhluvdemo.github.io/tags/算法竞赛/"}]},{"title":"EDA笔记","slug":"EDA笔记","date":"2019-08-15T14:53:39.000Z","updated":"2019-08-22T02:18:10.281Z","comments":true,"path":"2019/08/15/ck0qvueu60000bwudgj0pk37n/","link":"","permalink":"https://lwhluvdemo.github.io/2019/08/15/ck0qvueu60000bwudgj0pk37n/","excerpt":"控制大小、改变X轴字段方向 12plt.figure(figsize=(9,6))plt.xticks(fontsize=12,rotation=45) 改变x轴标签： 123loc, labels = plt.xticks()loc, labels = loc, [\"not know\", \"network\", \"WiFi\", \"cellular\", \"2G\", \"3G\", \"4G\",\"no\"]plt.xticks(loc, labels,fontsize=12)","text":"控制大小、改变X轴字段方向 12plt.figure(figsize=(9,6))plt.xticks(fontsize=12,rotation=45) 改变x轴标签： 123loc, labels = plt.xticks()loc, labels = loc, [\"not know\", \"network\", \"WiFi\", \"cellular\", \"2G\", \"3G\", \"4G\",\"no\"]plt.xticks(loc, labels,fontsize=12) 二分类标签（0，1）分布： 1sns.countplot(train_df['favorite'].sort_values()) 单个变量（连续或者类别）： 12sns.distplot(train.revenue)# blog 如果连续变量不服从正太分布： 123train['logRevenue'] = np.log1p(train['revenue'])sns.distplot(train['logRevenue'] )#------EDA, Feature Engineering, LGB+XGB+CAT：电影预测比赛 （最后需要变换回来） 对两个特征的连续变量： 123sns.jointplot(x=\"runtime\", y=\"revenue\", data=train, height=11, ratio=4, color=\"g\")plt.show()#------EDA, Feature Engineering, LGB+XGB+CAT：电影预测比赛 对类别属性： 单个类别值（按顺序）计数：例如时间类特征 12345678plt.figure(figsize=(20,12))sns.countplot(train['release_month'].sort_values())plt.title(\"Release Month Count\",fontsize=20)loc, labels = plt.xticks()loc, labels = loc, [\"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"]plt.xticks(loc, labels,fontsize=20)plt.show()#----------kaggle_baseline反欺诈算法挑战赛：IEEE 例如二分类问题： 123456789# 对正负标签值查看关于某个特征的数值分布plt.figure(figsize=(9,6))sns.countplot(hue='label',x='ntt',data=All_data_for_train)loc, labels = plt.xticks()loc, labels = loc, [\"not know\", \"network\", \"WiFi\", \"cellular\", \"2G\", \"3G\", \"4G\",\"no\"]plt.xticks(loc, labels,fontsize=12)# plt.xticks(fontsize=12,rotation=45)plt.title(\"ntt Count\",fontsize=15)#----------2019移动广告反欺诈算法挑战赛 或者，以正负标签为X轴，观察其对另一特征的数值特点 123sns.catplot(x=\"has_homepage\", y=\"revenue\", data=train)plt.title('Revenue of movies with and without homepage')#------EDA, Feature Engineering, LGB+XGB+CAT：电影预测比赛","categories":[],"tags":[{"name":"EDA","slug":"EDA","permalink":"https://lwhluvdemo.github.io/tags/EDA/"},{"name":"机器学习","slug":"机器学习","permalink":"https://lwhluvdemo.github.io/tags/机器学习/"}]},{"title":"用GitHub Pages 和 Hexo搭建博客","slug":"GitHub Pages and Hexo","date":"2019-07-30T14:53:39.000Z","updated":"2019-07-31T07:01:56.913Z","comments":true,"path":"2019/07/30/ck0qvuevg000rbwudub0u5sva/","link":"","permalink":"https://lwhluvdemo.github.io/2019/07/30/ck0qvuevg000rbwudub0u5sva/","excerpt":"GitHub Pages 首先可以看这篇文章在GitHub上创建和托管个人网站，熟悉一下git的基本工作流程以及在GitHub上创建和托管个人网站实施步骤，以便对一些模糊的概念有所理解。熟悉工作流程或者不感兴趣的话可以跳过这一步，并不影响整个博客的搭建。","text":"GitHub Pages 首先可以看这篇文章在GitHub上创建和托管个人网站，熟悉一下git的基本工作流程以及在GitHub上创建和托管个人网站实施步骤，以便对一些模糊的概念有所理解。熟悉工作流程或者不感兴趣的话可以跳过这一步，并不影响整个博客的搭建。 创建项目的存储库。登录您的GitHub帐户并转到https://github.com/new，或点击您帐户主页上的新建存储库图标。 为存储库命名username.github.io，替换username为您的GitHub用户名(命名格式必须严格按照这个)。然后确保它是公开的(Public)，勾选创建README文件选项，然后创建存储库。 Hexo 环境搭建参考自：Hexo官方文档 安装Git：从其官网下载务必挂代理，没有的话从这个页面下载存储于百度云的资源。 安装Node.js 对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选Add to PATH选项。 另外，也可以使用Git Bash，这是git for windows自带的一组程序，提供了Linux风格的shell，在该环境下，可以直接用上面提到的命令来安装Node.js。打开它的方法很简单，在任意位置单击右键，选择“Git Bash Here”即可。由于Hexo的很多操作都涉及到命令行，可以考虑始终使用Git Bash来进行操作。 安装Hexo由于某些大家都知道的缘故，npm官方源在国内的下载速度极其慢，用官网的npm install hexo-cli -g速度非常感人，所以不推荐这种方式。推荐用淘宝的npm分流–cnpmnpm install -g cnpm --registry=https://registry.npm.taobao.org 之后的用法和npm一样，无非是把npm install改成cnpm install,但是速度比之前快了不止一个数量级。 检查： node -v,git --version,hexo -v。 除特殊说明，所有命令行语句都在/d/blog路径下进行，并且只用Git Bash，不要用CMD 本地博客 任选一位置创建文件夹 blog，在blog文件夹空白处右键选择 Git Bash Here. 输入 hexo init 将 blog 文件夹初始化成一个博客文件夹。 输入 npm install –&gt;安装依赖包。 输入 hexo g –&gt;生成运行环境。 输入 hexo s 将生成的网页放在了本地服务器（server）。 浏览器里输入 http://localhost:4000/ , 就可以看到刚才的成果了。 回到 Git Bash，按 Ctrl+C 终止本地服务器。 部署到 Github 上 获取 Github 对应存储库(即你创建的username.github.io)的链接。eg：https://github.com/lwhluvdemo/lwhluvdemo.github.io.git 修改博客的配置文件打开blog文件夹下的_config.yml文件(我自己用的是ultraEdit,VS code、notepad++等也可以)找到 #Deployment，填入以下内容： 这里要注意，凡是修改配置文件，属性名的冒号后面一定要有一个空格才能加属性值，不然会报错 1234deploy: type: git repository: https://github.com/lwhluvdemo/lwhluvdemo.github.io.git## 用第一步得到的链接 branch: master 回到 Git Bash，输入 npm install hexo-deployer-git --save 安装 hexo-deployer-git 此步骤只需要做一次。 输入 hexo d，得到 INFO Deploy done: git 即为部署成功。 之后写博文常用hexo g -d部署。 可以使用hexo clean命令来清除缓存，也就是删除.public文件夹，如果以后出现一些看不懂的bug，可以试试先clean再重新hexo g也许可以解决。 新建博文 我们的.md博文都存放在..\\blog\\source\\_posts目录下，我们可以通过删除本地文件重新部署的方式来删除博文，当然也可以新建一个md文件。 另一种是用命令行新建，打开GitBash输入： 1hexo new \"文章标题\" 在_posts文件夹中找到刚刚新建的md文件，里面有 12345---title: 文章标题date: 创建文章的时间tags: 文章标签--- 对上面的内容进行修改，或者直接开始往下写，写完保存之后，通过hexo g、hexo d来更新你的博客。 美化 到官方主题站搜索自己喜欢的主题，都附有配置解释文档的以及使用方式 安装主题的统一方式是，打开GitBash： 1git clone 主题GitHub仓库地址 themes/主题名 打开 D:/blog/_config.yml文件，在一般在倒数第6，7行，找到theme:,后面的内容改为代码行里的主题名。 找到 # Site，添加博客名称，作者名字等。 在 language 后面填入 en 或者 zh-CN，选择英文或者中文。(一般在..\\blog\\themes\\主题名\\languages里可以看到主题支持的语言) 找到 # URL, 填入 url。比如 url: https://lwhluvdemo.github.io/。 在GitBash重新生成部署：hexo g -d. 为博客选择图床 给博文配图： 把图片存放到相应的资源文件夹，随博客一起部署到GitHub 通过利用Markdown语法给博文添加图片链接，在观看博文的时候在线加载图片。 博客写作 Fancybox图片预览将需要放大预览的图片用&lt;fancybox&gt; &lt;/fancybox&gt;包含起来。 一行显示多图将多个图片同时放在一对&lt;fancybox&gt; &lt;/fancybox&gt;中即可 颜文字太空小孩。 颜文字. emoji表情Emoji Homepage. Markdown玩转Emoji. 图片带链接：1[![alt text](http://path/to/img.jpg \"title\")](你的链接地址) 评论设置gitalk.id实现多个页面共用一个评论框 在文章的Front-matter中： 1234---gitalk: id: /wiki/material-x/--- 页面配置见官方文档. 图床 vim-cn.sh.是一个十分干净好用的图床，本站以及博客中的所有图片都是使用的这个图床。所以，这是一个快速批量上传图片的脚本。（勿滥用） 关于添加评论插件和设置个性化域名遇到的错误 要设置个性化域名，为自己的域名做这些设置（为gitalk评论插件做准备），然后从GitHub的博客存储库的设置最下面Custom domain填入自己的域名（我自己的是lwhluvdemo.ml），再在本地博客根目录的source下新建一个无后缀CNAME文件填入自己的个性域名，否则每次hexo g -d都会重置。 GitHub个人主页Settings-&gt;Developer settings-&gt;OAuth Apps，具体可以参考这个文档的 Gitalk，获得建立评论区clientID和clientSecret，之后在Homepage URL填自己博客的地址，例如我的博客：https://lwhluvdemo.github.io/ 以及Authorization callback URL填写自己的域名地址，例如我的域名：https://lwhluvdemo.ml/. 两个地址后面都要加 /。 如果前面是按照我的设置来的话，一般不会有hexo配置gitalk 评论后无法初始化创建issue的问题 解决Error: Validation Failed错误最后是根目录下_config.yml配置文件的改变，主要是将permalink的title变为id来避免超过50个字符的限制 网上流传的很流行的md5方法等，我。。。。一个也不会用，主要是他们说的在哪哪添加文件，我根本就没有那些路径，所以想用也没办法。 大部分与MD5相关的答案可以从这里找到。 123456# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: https://lwhluvdemo.github.ioroot: /permalink: :year/:month/:day/:id/permalink_defaults: 1234567gitalk: clientID: ************** clientSecret: *********************** repo: yourname.github.io owner: yourname admin: [yourname] id: decodeURI(window.location.pathname) 一般提交后需要几分钟来重新部署，立刻刷新网页不会变……等等就好。","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://lwhluvdemo.github.io/tags/Hexo/"},{"name":"GitHub Pages","slug":"GitHub-Pages","permalink":"https://lwhluvdemo.github.io/tags/GitHub-Pages/"}]}]}